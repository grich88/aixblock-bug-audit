#!/usr/bin/env python3
"""
Vulnerability Database Integrator
Cross-references multiple vulnerability databases for comprehensive threat intelligence
"""

import requests
import json
import time
from datetime import datetime, timedelta
import re

class VulnerabilityDatabaseIntegrator:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.vulnerabilities = []
        
    def query_nvd(self, cve_id=None, keyword=None):
        """Query National Vulnerability Database"""
        print(f"üîç Querying NVD for {cve_id or keyword}")
        
        try:
            if cve_id:
                url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
            else:
                url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}"
                
            response = self.session.get(url, timeout=30)
            if response.status_code == 200:
                data = response.json()
                return data.get('vulnerabilities', [])
        except Exception as e:
            print(f"Error querying NVD: {e}")
        return []
    
    def query_osv(self, package_name=None, ecosystem=None):
        """Query Open Source Vulnerability database"""
        print(f"üîç Querying OSV for {package_name or 'recent vulnerabilities'}")
        
        try:
            if package_name:
                url = "https://osv-vulnerabilities.storage.googleapis.com/"
                # OSV uses a different API structure
                response = self.session.get(f"{url}{package_name}/all.zip", timeout=30)
            else:
                # Query recent vulnerabilities
                url = "https://osv.dev/query"
                payload = {
                    "query": "ecosystem:PYPI",
                    "page": 1,
                    "per_page": 100
                }
                response = self.session.post(url, json=payload, timeout=30)
                
            if response.status_code == 200:
                return response.json()
        except Exception as e:
            print(f"Error querying OSV: {e}")
        return []
    
    def query_github_advisories(self, repo=None):
        """Query GitHub Security Advisories"""
        print(f"üîç Querying GitHub advisories for {repo or 'recent'}")
        
        try:
            if repo:
                url = f"https://api.github.com/repos/{repo}/security-advisories"
            else:
                url = "https://api.github.com/advisories"
                
            response = self.session.get(url, timeout=30)
            if response.status_code == 200:
                return response.json()
        except Exception as e:
            print(f"Error querying GitHub: {e}")
        return []
    
    def query_cve_details(self, cve_id):
        """Query CVE Details database"""
        print(f"üîç Querying CVE Details for {cve_id}")
        
        try:
            url = f"https://www.cvedetails.com/cve/{cve_id}/"
            response = self.session.get(url, timeout=30)
            if response.status_code == 200:
                # Parse HTML for vulnerability details
                return self.parse_cve_details(response.text)
        except Exception as e:
            print(f"Error querying CVE Details: {e}")
        return {}
    
    def parse_cve_details(self, html):
        """Parse CVE Details HTML for vulnerability information"""
        details = {}
        
        # Extract CVSS score
        cvss_match = re.search(r'CVSS Score: (\d+\.\d+)', html)
        if cvss_match:
            details['cvss_score'] = float(cvss_match.group(1))
            
        # Extract vulnerability type
        vuln_type_match = re.search(r'Vulnerability Type: ([^<]+)', html)
        if vuln_type_match:
            details['vulnerability_type'] = vuln_type_match.group(1).strip()
            
        # Extract exploit availability
        exploit_match = re.search(r'Exploit Available: ([^<]+)', html)
        if exploit_match:
            details['exploit_available'] = exploit_match.group(1).strip()
            
        return details
    
    def query_dark_web_intelligence(self):
        """Simulate dark web intelligence gathering"""
        print("üîç Gathering dark web intelligence...")
        
        # Simulate dark web forum monitoring
        dark_web_intel = {
            'trending_exploits': [
                'CVE-2024-1708',  # ConnectWise ScreenConnect
                'CVE-2024-3400',  # Palo Alto GlobalProtect
                'CVE-2024-55591', # Fortinet FortiOS
                'CVE-2025-30400', # Windows DWM Core
                'CVE-2025-32701'  # CLFS driver
            ],
            'active_ransomware_groups': [
                'LockBit',
                'BlackCat',
                'Royal',
                'Play'
            ],
            'exploit_prices': {
                'CVE-2024-1708': '$50,000',
                'CVE-2024-3400': '$75,000',
                'CVE-2024-55591': '$30,000'
            },
            'target_industries': [
                'Healthcare',
                'Education',
                'Financial Services',
                'AI/ML Companies'
            ]
        }
        
        return dark_web_intel
    
    def analyze_ai_framework_vulnerabilities(self):
        """Analyze AI/ML framework vulnerabilities"""
        print("ü§ñ Analyzing AI framework vulnerabilities...")
        
        ai_frameworks = [
            'tensorflow',
            'pytorch',
            'scikit-learn',
            'keras',
            'huggingface',
            'transformers',
            'langchain',
            'openai'
        ]
        
        ai_vulnerabilities = []
        
        for framework in ai_frameworks:
            # Query for framework-specific vulnerabilities
            nvd_results = self.query_nvd(keyword=framework)
            osv_results = self.query_osv(package_name=framework)
            
            for vuln in nvd_results:
                if vuln.get('cve', {}).get('descriptions', []):
                    description = vuln['cve']['descriptions'][0]['value']
                    if any(keyword in description.lower() for keyword in ['ai', 'ml', 'model', 'training', 'inference']):
                        ai_vulnerabilities.append({
                            'framework': framework,
                            'cve': vuln['cve']['id'],
                            'description': description,
                            'severity': self.get_severity(vuln),
                            'source': 'NVD'
                        })
        
        return ai_vulnerabilities
    
    def get_severity(self, vuln):
        """Extract severity from vulnerability data"""
        if 'metrics' in vuln and 'cvssMetricV31' in vuln['metrics']:
            cvss_data = vuln['metrics']['cvssMetricV31'][0]['cvssData']
            base_score = cvss_data['baseScore']
            
            if base_score >= 9.0:
                return 'CRITICAL'
            elif base_score >= 7.0:
                return 'HIGH'
            elif base_score >= 4.0:
                return 'MEDIUM'
            else:
                return 'LOW'
        return 'UNKNOWN'
    
    def generate_threat_intelligence_report(self):
        """Generate comprehensive threat intelligence report"""
        print("üìä Generating threat intelligence report...")
        
        # Gather intelligence from multiple sources
        dark_web_intel = self.query_dark_web_intelligence()
        ai_vulnerabilities = self.analyze_ai_framework_vulnerabilities()
        
        # Query recent high-severity vulnerabilities
        recent_vulns = self.query_nvd(keyword="remote code execution")
        
        # Generate report
        report = {
            'timestamp': datetime.now().isoformat(),
            'dark_web_intelligence': dark_web_intel,
            'ai_framework_vulnerabilities': ai_vulnerabilities,
            'recent_high_severity': recent_vulns[:10],  # Top 10 recent vulnerabilities
            'recommendations': self.generate_recommendations()
        }
        
        return report
    
    def generate_recommendations(self):
        """Generate security recommendations based on intelligence"""
        recommendations = [
            {
                'priority': 'CRITICAL',
                'action': 'Patch RMM tools immediately',
                'reason': 'CVE-2024-1708 and CVE-2024-57727 are actively exploited',
                'timeline': 'Immediate'
            },
            {
                'priority': 'HIGH',
                'action': 'Update VPN and edge devices',
                'reason': 'Palo Alto CVE-2024-3400 and Ivanti CVEs are trending',
                'timeline': 'Within 48 hours'
            },
            {
                'priority': 'HIGH',
                'action': 'Implement AI model security controls',
                'reason': 'AI framework vulnerabilities are emerging threat',
                'timeline': 'Within 1 week'
            },
            {
                'priority': 'MEDIUM',
                'action': 'Monitor dark web for company mentions',
                'reason': 'Proactive threat intelligence gathering',
                'timeline': 'Ongoing'
            }
        ]
        
        return recommendations
    
    def save_report(self, report):
        """Save threat intelligence report to file"""
        filename = f"threat_intelligence_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
            
        print(f"üìÑ Threat intelligence report saved to: {filename}")
        return filename

def main():
    """Main execution function"""
    print("üöÄ Starting Vulnerability Database Integration")
    print("=" * 60)
    
    integrator = VulnerabilityDatabaseIntegrator()
    
    # Generate comprehensive threat intelligence report
    report = integrator.generate_threat_intelligence_report()
    
    # Save report
    filename = integrator.save_report(report)
    
    print("\nüéØ Key Findings:")
    print(f"   ‚Ä¢ Dark web trending exploits: {len(report['dark_web_intelligence']['trending_exploits'])}")
    print(f"   ‚Ä¢ AI framework vulnerabilities: {len(report['ai_framework_vulnerabilities'])}")
    print(f"   ‚Ä¢ Recent high-severity: {len(report['recent_high_severity'])}")
    print(f"   ‚Ä¢ Security recommendations: {len(report['recommendations'])}")
    
    print(f"\nüìä Report saved to: {filename}")
    print("üí° Use this intelligence to prioritize your security testing")

if __name__ == "__main__":
    main()
